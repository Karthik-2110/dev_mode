<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Dev Mode Lite</title>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      margin: 0;
      padding: 0;
      background-color: #2C2C2C;
      color: #FFFFFF;
    }

    .header {
      padding: 12px 16px;
      border-bottom: 1px solid #444444;
      background-color: #2C2C2C;
    }
    .empty-state {
      padding: 20px;
      text-align: center;
      color: rgba(255, 255, 255, 0.6);
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .empty-state-icon {
      margin-bottom: 16px;
      opacity: 0.6;
      width: 32px;
      height: 32px;
    }

    .section_wrapper {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0px 16px;
    }

    .section {
      /* margin-bottom: 24px; */
      padding: 16px 16px;
      background-color: #2C2C2C;
    }

    .section-title {
      font-size: 12px;
      font-weight: 400;
      color: #fff;
      border-radius: 4px;
      width: fit-content;
    }

    .color-section {
      padding: 16px 0px;
      background-color: #2C2C2C;
      border-top: 1px solid #444444;
    }

    .language-section-choice {
      font-size: 10px;
      font-weight: 400;
      color: #fff;
      padding: 5px 8px;
      border: 1px solid #676767;
      border-radius: 4px;
      width: fit-content;
      display: flex;
      align-items: center;
      position: relative;
    }

    .language-section-choice select {
      appearance: none;
      -webkit-appearance: none;
      background: transparent;
      border: none;
      font-size: 10px;
      font-weight: 400;
      color: #fff;
      padding-right: 16px;
      cursor: pointer;
      outline: none;
      width: 100%;
    }

    .language-section-choice select:focus {
      outline: none;
      box-shadow: none;
    }

    .language-section-choice select option {
      background-color: #2C2C2C;
      color: #fff;
    }

    .section-choice {
      font-size: 10px;
      font-weight: 400;
      color: #fff;
      padding: 5px 8px;
      border: 1px solid #444444;
      border-radius: 4px;
      width: fit-content;
      display: flex;
      align-items: center;
      position: relative;
    }

    .section-choice select {
      appearance: none;
      -webkit-appearance: none;
      background: transparent;
      border: none;
      font-size: 10px;
      font-weight: 400;
      color: #fff;
      padding-right: 16px;
      cursor: pointer;
      outline: none;
      width: 100%;
    }

    .section-choice select:focus {
      outline: none;
      box-shadow: none;
    }

    .section-choice select option {
      background-color: #2C2C2C;
      color: #fff;
    }

    .section-choice-icon {
      width: 12px;
      height: 12px;
      background-size: contain;
      background-repeat: no-repeat;
      background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMS4yNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0ibHVjaWRlIGx1Y2lkZS1jaGV2cm9uLWRvd24taWNvbiBsdWNpZGUtY2hldnJvbi1kb3duIj48cGF0aCBkPSJtNiA5IDYgNiA2LTYiLz48L3N2Zz4=");
      position: absolute;
      right: 8px;
      pointer-events: none;
    }

    .property-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 16px;
    }
    .property-name {
      font-size: 13px;
      color: rgba(255, 255, 255, 0.7);
    }
    .property-value {
      font-size: 13px;
      color: #FFFFFF;
      font-weight: 500;
    }
    .color-sample {
      display: inline-block;
      width: 16px;
      height: 16px;
      border-radius: 3px;
      vertical-align: middle;
      margin-right: 4px;
    }
    .color-list {
      width: 100%;
      display: flex;
      flex-direction: column;
      margin-top: 6px;
    }

    .color-item {
      display: flex;
      align-items: center;
      padding: 10px 16px;
      justify-content: space-between;
      cursor: pointer;
      position: relative;
    }

    .color-item:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .color-left {
      display: flex;
      align-items: center;
    }

    .color-right {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
      text-overflow: ellipsis;
      overflow: hidden;
      white-space: nowrap;
      width: 32%;
      text-align: right;
    }

    .color-item:last-child {
      margin-bottom: 0;
    }
    .color-swatch {
      width: 10px;
      height: 10px;
      margin-right: 8px;
    }
    .color-swatch.border {
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.1);
    }
    .color-info {
      flex: 1;
    }
    .color-name {
      font-size: 12px;
      font-weight: 400;
      color: #FFFFFF;
    }
    .color-value {
      font-family: 'SF Mono', 'Roboto Mono', monospace;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
    }
    .color-format-selector {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 0 12px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      margin-bottom: 16px;
    }
    .color-format-title {
      font-size: 13px;
      color: #FFFFFF;
    }
    .color-format-dropdown {
      background-color: #232323;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 4px;
      color: #FFFFFF;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 6px center;
      background-size: 16px;
      padding-right: 28px;
    }
    .color-format-dropdown:focus {
      outline: none;
      border-color: transparent;
    }
    .dropdown-container {
      position: relative;
      display: inline-block;
      border-radius: 4px;
    }
    button {
      border: none;
      border-radius: 6px;
      background-color: #18A0FB;
      color: white;
      padding: 8px 12px;
      font-size: 12px;
      cursor: pointer;
      margin-top: 12px;
    }
    button:hover {
      background-color: #0D8DE3;
    }
    .footer {
      padding: 16px;
      text-align: center;
    }
    svg {
      fill: #FFFFFF;
    }
    .empty-message {
      color: rgba(255, 255, 255, 0.6);
      font-style: italic;
      text-align: center;
      padding: 12px 0;
    }
    .dimensions-row {
      display: flex;
      background-color: #3B4364;
      border-radius: 6px;
      margin-top: 8px;
      overflow: hidden;
    }
    .dimensions-label {
      display: flex;
      justify-content: center;
      align-items: center;
      width: 30px;
      background-color: rgba(0, 0, 0, 0.3);
      color: rgba(255, 255, 255, 0.8);
      font-size: 12px;
    }
    .dimensions-value {
      flex: 1;
      padding: 6px 10px;
      font-size: 12px;
      color: #FFFFFF;
    }

    .parent-box-model {
      background-color: #383838;
      width: auto;
      height: auto;
      margin-top: 12px;
      border-radius: 6px;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 20px 10px;
    }

    .box-model {
      position: relative;
      font-family: 'Inter', sans-serif;
      color: #FFFFFF;
      width: 85%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    .box-border {
      position: relative;
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 6px;
      width: 80%;
      padding: 30px;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #2C2C2C;
    }
    
    .box-padding {
      position: relative;
      border: 1px solid rgba(255, 255, 255, 0.6);
      border-radius: 4px;
      width: 67%;
      padding: 30px;
      background-color: #3B4364;
    }
    
    .box-content {
      position: relative;
      border: 1px dashed rgba(255, 255, 255, 0.7);
      width: 85%;
      height: 48px;
      margin-left: 13px;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #2C2C2C;
      border-radius: 4px;
    }

    #content-dimensions {
      font-size: 12px;
      font-weight: 400;
      color: #FFFFFF;
      opacity: 0.9;
    }
    
    .box-label {
      position: absolute;
      top: 7px;
      left: 22px;
      font-size: 12px;
      background-color: inherit;
      padding: 0 8px;
      z-index: 2;
    }
    
    .border-label {
      color: #FFFFFF;
      opacity: 0.8;
    }
    
    .padding-label {
      color: #FFFFFF;
      opacity: 0.8;
    }
    
    .box-value {
      position: absolute;
      font-size: 12px;
      font-weight: 400;
      color: #fff;
      opacity: 0.8;
      z-index: 5;
    }

    .border-top-value {
      top: 6px;
      left: 12px;
      transform: translateX(-50%);
    }
    
    .border-right-value {
      right: 8px;
      top: 13px;
      transform: translateY(-50%);
    }
    
    .border-bottom-value {
      bottom: 6px;
      right: 6px;
      transform: translateX(-50%);
    }
    
    .border-left-value {
      left: 8px;
      bottom: 0px;
      transform: translateY(-50%);
    }
    
    .top-value {
      top: 6px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .right-value {
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .bottom-value {
      bottom: 6px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .left-value {
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
    }

    .welcome-icon {
      width: 32px;
      height: 32px;
      background-size: contain;
      background-repeat: no-repeat;
      background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMS4yNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0ibHVjaWRlIGx1Y2lkZS1tb3VzZS1wb2ludGVyLWNsaWNrLWljb24gbHVjaWRlLW1vdXNlLXBvaW50ZXItY2xpY2siPjxwYXRoIGQ9Ik0xNCA0LjEgMTIgNiIvPjxwYXRoIGQ9Im01LjEgOC0yLjktLjgiLz48cGF0aCBkPSJtNiAxMi0xLjkgMiIvPjxwYXRoIGQ9Ik03LjIgMi4yIDggNS4xIi8+PHBhdGggZD0iTTkuMDM3IDkuNjlhLjQ5OC40OTggMCAwIDEgLjY1My0uNjUzbDExIDQuNWEuNS41IDAgMCAxLS4wNzQuOTQ5bC00LjM0OSAxLjA0MWExIDEgMCAwIDAtLjc0LjczOWwtMS4wNCA0LjM1YS41LjUgMCAwIDEtLjk1LjA3NHoiLz48L3N2Zz4=");
    }

    .welcome-message {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      width: auto;
      text-align: center;
      color: rgba(255, 255, 255, 0.8);
      box-sizing: border-box;
    }
    .welcome-message h2 {
      font-size: 16px;
      margin-bottom: 6px;
      font-weight: 500;
    }
    .welcome-message p {
      font-size: 12px;
      opacity: 0.7;
      margin: 0;
    }
    .color-preview {
      width: 18px;
      height: 18px;
      border-radius: 4px;
      margin-right: 16px;
    }
    .color-values {
      margin-top: 2px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
      display: flex;
      align-items: center;
      font-family: 'SF Mono', 'Roboto Mono', monospace;
    }

    .color-preview-container {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: row;
    }

    .color-format {
      font-size: 12px;
      margin-bottom: 4px;
    }
    .color-format span:first-child {
      color: rgba(255, 255, 255, 0.6);
      width: 40px;
    }
    .stroke-info {
      display: flex;
      align-items: center;
    }
    #stroke-weight {
      font-size: 13px;
      color: #FFFFFF;
      font-weight: 500;
    }
    .element-name-container {
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .component-icon-container {
      display: flex;
      align-items: center;
      margin-top: 12px;
    }

    .element-name {
      font-size: 14px;
      font-weight: 500;
      color: #FFFFFF;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .component-icon {
      width: 16px;
      height: 16px;
      margin-right: 6px;
      background-size: contain;
      background-repeat: no-repeat;
      background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMS4yNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0ibHVjaWRlIGx1Y2lkZS1zcXVhcmUtZGFzaGVkLW1vdXNlLXBvaW50ZXItaWNvbiBsdWNpZGUtc3F1YXJlLWRhc2hlZC1tb3VzZS1wb2ludGVyIj48cGF0aCBkPSJNMTIuMDM0IDEyLjY4MWEuNDk4LjQ5OCAwIDAgMSAuNjQ3LS42NDdsOSAzLjVhLjUuNSAwIDAgMS0uMDMzLjk0M2wtMy40NDQgMS4wNjhhMSAxIDAgMCAwLS42Ni42NmwtMS4wNjcgMy40NDNhLjUuNSAwIDAgMS0uOTQzLjAzM3oiLz48cGF0aCBkPSJNNSAzYTIgMiAwIDAgMC0yIDIiLz48cGF0aCBkPSJNMTkgM2EyIDIgMCAwIDEgMiAyIi8+PHBhdGggZD0iTTUgMjFhMiAyIDAgMCAxLTItMiIvPjxwYXRoIGQ9Ik05IDNoMSIvPjxwYXRoIGQ9Ik05IDIxaDIiLz48cGF0aCBkPSJNMTQgM2gxIi8+PHBhdGggZD0iTTMgOHYxIi8+PHBhdGggZD0iTTIxIDl2MiIvPjxwYXRoIGQ9Ik0zIDE0djEiLz48L3N2Zz4=");
    }

    .element-type {
      /* margin-top: 8px; */
      font-size: 12px;
      color: #fff;
      letter-spacing: 0.05em;
    }


    .layout_wrapper {
      background-color: #383838;
      width: 100%;
      height: auto;
      border-radius: 6px;
      overflow: hidden;
      margin-top: 12px;
    }

    .layout_header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      /* padding: 6px 12px; */
      border-bottom: 1px solid #686868;
    }

    .layout_title {
      font-size: 12px;
      color: #FFFFFF;
      font-weight: 400;
      padding: 0 12px;
    }

    .layout_header_right {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .layout_copy_icon { 
      height: 16px;
      width: 16px;
      margin-right: 12px;
      background-size: contain;
      background-repeat: no-repeat;
      cursor: pointer;
      background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMS4yNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0ibHVjaWRlIGx1Y2lkZS1jbGlwYm9hcmQtbGlzdC1pY29uIGx1Y2lkZS1jbGlwYm9hcmQtbGlzdCI+PHJlY3Qgd2lkdGg9IjgiIGhlaWdodD0iNCIgeD0iOCIgeT0iMiIgcng9IjEiIHJ5PSIxIi8+PHBhdGggZD0iTTE2IDRoMmEyIDIgMCAwIDEgMiAydjE0YTIgMiAwIDAgMS0yIDJINmEyIDIgMCAwIDEtMi0yVjZhMiAyIDAgMCAxIDItMmgyIi8+PHBhdGggZD0iTTEyIDExaDQiLz48cGF0aCBkPSJNMTIgMTZoNCIvPjxwYXRoIGQ9Ik04IDExaC4wMSIvPjxwYXRoIGQ9Ik04IDE2aC4wMSIvPjwvc3ZnPg==");
    }

    .layout_copy_icon:hover {
      opacity: 0.7;
    }

    .layout_content {
      padding: 12px 12px 6px 12px;
    }

    .layout_row {
      display: flex;
      align-items: center;
      margin-bottom: 6px;
    }

    .layout_label {
      font-size: 12px;
      color: #FFFFFF;
      font-weight: 400;
      opacity: 0.8;
    }

    .layout_value {
      font-size: 12px;
      color: #FD9BDF;
      font-weight: 400;
      margin-left: 6px;
    }
    
    .assets-section {
      padding: 16px 0px;
      background-color: #2C2C2C;
      border-top: 1px solid #444444;
    }

    .assets-list {
      width: 100%;
      display: flex;
      flex-direction: column;
      margin-top: 6px;
    }

    .asset-item {
      display: flex;
      align-items: center;
      padding: 10px 16px;
      justify-content: space-between;
      cursor: pointer;
      position: relative;
    }

    .asset-item:hover {
      background-color: rgba(255, 255, 255, 0.1);
    }

    .asset-item:hover .asset-right {
      opacity: 1;
      pointer-events: auto;
    }

    .asset-left {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .asset-preview {
      width: 42px !important;
      height: 42px !important;
      min-width: 42px !important;
      min-height: 42px !important;
      border-radius: 4px;
      background-color: #383838;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }

    .asset-preview img {
      width: 100%;
      height: 100%;
      object-fit: contain !important;
      background-size: contain !important;
      background-repeat: no-repeat !important;
      background-position: center !important;
      padding: 6px;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      -webkit-transform: translateZ(0) scale(1.0, 1.0);
      transform: translateZ(0);
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
    }

    .asset-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .asset-name {
      font-size: 12px;
      color: #FFFFFF;
      font-weight: 400;
    }

    .asset-type {
      font-size: 10px;
      font-weight: 400;
      color: rgba(255, 255, 255, 0.6);
    }

    .asset-right {
      display: flex;
      align-items: center;
      gap: 8px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
    }

    .asset-item:hover .asset-right {
      opacity: 1;
      pointer-events: auto;
    }

    .asset-format-select {
      background: #2C2C2C;
      border: transparent;
      border-radius: 4px;
      color: #FFFFFF;
      font-size: 10px;
      padding: 6px 8px;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      padding-right: 24px;
      background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMS4yNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0ibHVjaWRlIGx1Y2lkZS1jaGV2cm9uLWRvd24taWNvbiBsdWNpZGUtY2hldnJvbi1kb3duIj48cGF0aCBkPSJtNiA5IDYgNiA2LTYiLz48L3N2Zz4=");
      background-repeat: no-repeat;
      background-position: right 4px center;
      background-size: 14px;
    }

    .asset-format-select:focus,
    .asset-resolution-select:focus {
      outline: none;
      box-shadow: none;
    }

    .asset-resolution-select {
      display: none;
      background: #2C2C2C;
      border: transparent;
      border-radius: 4px;
      color: #FFFFFF;
      font-size: 10px;
      padding: 6px 8px;
      cursor: pointer;
      appearance: none;
      -webkit-appearance: none;
      padding-right: 24px;
      margin-left: 4px;
      background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMS4yNSIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBjbGFzcz0ibHVjaWRlIGx1Y2lkZS1jaGV2cm9uLWRvd24taWNvbiBsdWNpZGUtY2hldnJvbi1kb3duIj48cGF0aCBkPSJtNiA5IDYgNiA2LTYiLz48L3N2Zz4=");
      background-repeat: no-repeat;
      background-position: right 4px center;
      background-size: 14px;
    }

    .asset-download {
      height: 24px;
      width: 24px;
      border-radius: 4px;
      background-color: #2C2C2C;
      color: #FFFFFF;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .download-icon {
      width: 12px;
      height: 12px;
      background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiBzdHJva2U9IiNmZmZmZmYiIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj48cGF0aCBkPSJNMjEgMTV2NGEyIDIgMCAwIDEtMiAySDVhMiAyIDAgMCAxLTItMnYtNCI+PC9wYXRoPjxwb2x5bGluZSBwb2ludHM9IjcgMTAgMTIgMTUgMTcgMTAiPjwvcG9seWxpbmU+PGxpbmUgeDE9IjEyIiB5MT0iMTUiIHgyPSIxMiIgeTI9IjMiPjwvbGluZT48L3N2Zz4=");
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
    }
  </style>
</head>
<body>
  <div id="no-selection" class="welcome-message">
    <div class="welcome-icon"></div>
    <h2>Select an element</h2>
    <p>Select a layer to inspect its properties</p>
  </div>
  
  <div id="inspector" style="display: none;">
    <!-- Header with element name -->
    <div class="header">
      <div class="element-name-container">
        <div id="element-name" class="element-name">Element Name</div>
        <div class="component-icon-container">  
          <div class="component-icon"></div>
          <div id="element-type" class="element-type">
            <!-- Icon and type will be populated by JS -->
          </div>
        </div>
      </div>
    </div>
    
    <div id="layout-section" class="section">
      <div class="section-title">Box model visualization</div>
      
      <!-- Box Model visualization -->
      <div class="parent-box-model">
        <div id="box-model-container" class="box-model">
          <div class="box-border">
            <span class="box-label border-label">Border</span>
            <span class="box-value border-top-value" id="border-top">8</span>
            <span class="box-value border-right-value" id="border-right">8</span>
            <span class="box-value border-bottom-value" id="border-bottom">8</span>
            <span class="box-value border-left-value" id="border-left">8</span>

            
            <span class="box-value top-value" id="stroke-top">1</span>
            <span class="box-value right-value" id="stroke-right">1</span>
            <span class="box-value bottom-value" id="stroke-bottom">1</span>
            <span class="box-value left-value" id="stroke-left">1</span>
            
            <div class="box-padding">
              <span class="box-label padding-label">Padding</span>
              <span class="box-value top-value" id="padding-top">12</span>
              <span class="box-value right-value" id="padding-right">137</span>
              <span class="box-value bottom-value" id="padding-bottom">12</span>
              <span class="box-value left-value" id="padding-left">137</span>
              
              <div class="box-content">
                <span id="content-dimensions">54 × 18</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Layout code -->
       <div class="layout_wrapper">
        <div class="layout_header">
          <p class="layout_title" id="layout_title">Layout</p>

          <div class="layout_header_right">
            <div class="language-section-choice">
              <select aria-label="Color format">
                <option value="css">CSS</option>
                <option value="tailwindcss">Tailwind CSS</option>
                <option value="bootstrap">Bootstrap</option>
                <option value="react">React</option>
                <option value="vue">Vue</option>
                <option value="svelte">Svelte</option>
                <option value="angular">Angular</option>
                <option value="qwik">Qwik</option>
                <option value="swift">Swift</option>
                <option value="flutter">Flutter</option>
                <option value="kotlin">Kotlin</option>
              </select>
              <div class="section-choice-icon" aria-hidden="true"></div>
            </div>

            <div class="layout_copy_icon"></div>
          </div>
        </div>

        <div class="layout_content"> 
          <!-- Content will be populated by JavaScript -->
        </div>
       </div>
      
    </div>
    
     <!-- colors section -->
     <div id="colors-section" class="color-section">
      <div class="section_wrapper">
        <div class="section-title">Selection colors</div>
        <div class="section-choice">
          <select aria-label="Color format">
            <option value="hex">Hex</option>
            <option value="hsl">HSL</option>
            <option value="hsb">HSB</option>
            <option value="rgb">RGB</option>
            <option value="css">CSS</option>
          </select>
          <div class="section-choice-icon" aria-hidden="true"></div>
        </div>
      </div>
      <div id="colors-list" class="color-list">
        <!-- Colors will be populated dynamically -->
      </div>
    </div>

       <!-- assets section -->
    <div id="assets-section" class="assets-section">
      <div class="section_wrapper">
        <div class="section-title">Assets</div>
      </div>
      <div id="assets-list" class="assets-list">
        <!-- Assets will be populated dynamically -->
      </div>
    </div>
    
  </div>

  <script>
    // Helper function to convert RGB to HEX
    function rgbToHex(r, g, b) {
      function componentToHex(c) {
        const hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      }
      return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);
    }
    
    // Function to convert RGB to HSL
    function rgbToHsl(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;

      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
          case g: h = (b - r) / d + 2; break;
          case b: h = (r - g) / d + 4; break;
        }
        h /= 6;
      }

      return {
        h: Math.round(h * 360),
        s: Math.round(s * 100),
        l: Math.round(l * 100)
      };
    }

    // Function to convert RGB to HSB
    function rgbToHsb(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const delta = max - min;
      
      let h, s;
      const v = max;
      
      if (delta === 0) {
        h = 0;
        s = 0;
      } else {
        s = delta / max;
        if (max === r) {
          h = (g - b) / delta + (g < b ? 6 : 0);
        } else if (max === g) {
          h = (b - r) / delta + 2;
        } else {
          h = (r - g) / delta + 4;
        }
        h /= 6;
      }
      
      return {
        h: Math.round(h * 360),
        s: Math.round(s * 100),
        b: Math.round(v * 100)
      };
    }

    // Function to get color value based on format
    function getColorValue(r, g, b, opacity, format) {
      switch (format) {
        case 'hex':
          return rgbToHex(r, g, b);
        case 'rgb':
          return `rgb(${r}, ${g}, ${b})`;
        case 'hsl':
          const hsl = rgbToHsl(r, g, b);
          return `hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`;
        case 'hsb':
          const hsb = rgbToHsb(r, g, b);
          return `hsb(${hsb.h}, ${hsb.s}%, ${hsb.b}%)`;
        case 'css':
          return opacity < 1 
            ? `rgba(${r}, ${g}, ${b}, ${opacity.toFixed(2)})`
            : rgbToHex(r, g, b);
        default:
          return rgbToHex(r, g, b);
      }
    }

    // Function to get display value (for showing in the UI)
    function getDisplayValue(r, g, b, opacity, format) {
      const colorValue = getColorValue(r, g, b, opacity, format);
      // Only show opacity percentage if it's not already included in the color value (like rgba)
      const showOpacity = !colorValue.includes('rgba') && opacity < 1;
      return showOpacity ? `${colorValue} ${Math.round(opacity * 100)}%` : colorValue;
    }

    // Function to get node type with proper icon
    function getNodeTypeInfo(node) {
      const typeMap = {
        COMPONENT: { type: 'Component', color: '#ffffff' },
        COMPONENT_SET: { type: 'Component Set', color: '#ffffff' },
        INSTANCE: { type: 'Instance', color: '#ffffff' },
        FRAME: { type: 'Frame', color: '#ffffff' },
        GROUP: { type: 'Group', color: '#ffffff' },
        RECTANGLE: { type: 'Rectangle', color: '#ffffff' },
        TEXT: { type: 'Text', color: '#ffffff' },
        VECTOR: { type: 'Vector', color: '#ffffff' },
        LINE: { type: 'Line', color: '#ffffff' },
        ELLIPSE: { type: 'Ellipse', color: '#ffffff' },
        POLYGON: { type: 'Polygon', color: '#ffffff' },
        STAR: { type: 'Star', color: '#ffffff' },
        BOOLEAN_OPERATION: { type: 'Boolean Operation', color: '#ffffff' },
        SLICE: { type: 'Slice', color: '#ffffff' }
      };

      return typeMap[node.type] || { type: node.type, color: '#ffffff' };
    }

    // Function to update the UI with node data
    function updateUI(data) {
      if (!data) {
        document.getElementById('inspector').style.display = 'none';
        document.getElementById('no-selection').style.display = 'flex';
        return;
      }

      document.getElementById('inspector').style.display = 'block';
      document.getElementById('no-selection').style.display = 'none';

      // Update element name and type
      document.getElementById('element-name').textContent = data.name || 'Unnamed';
      
      // Update type with proper styling
      const typeInfo = getNodeTypeInfo(data);
      const typeEl = document.getElementById('element-type');
      typeEl.textContent = typeInfo.type;
      typeEl.style.color = typeInfo.color;

      // Update layout section title based on node type
      const layoutTitle = document.getElementById('layout_title');
      layoutTitle.textContent = data.isText ? 'Text CSS' : 'CSS Properties';

      // Update layout section
      const layoutContent = document.querySelector('.layout_content');
      layoutContent.innerHTML = '';

      // Check if it's a text node
      if (data.isText) {
        updateTextLayout(data, layoutContent);
      } else {
        // Add frame CSS properties
        updateFrameLayout(data, layoutContent);
      }

      // Update box model
      updateBoxModel(data);

      // Update color preview
      updateColorPreview(data);
    }
    
    // Function to update the text layout properties
    function updateTextLayout(data, container) {
      // Add font properties
      if (data.fontName) {
        const fontFamily = data.fontName.family;
        const fontStyle = data.fontName.style;
        addLayoutProperty(container, 'font-family', `'${fontFamily}'`);
        
        // Font weight
        const weightMatch = fontStyle.match(/(\d+)/);
        if (weightMatch) {
          addLayoutProperty(container, 'font-weight', weightMatch[0]);
        } else if (fontStyle.includes('Bold')) {
          addLayoutProperty(container, 'font-weight', '700');
        } else if (fontStyle.includes('Medium')) {
          addLayoutProperty(container, 'font-weight', '500');
        } else if (fontStyle.includes('Light')) {
          addLayoutProperty(container, 'font-weight', '300');
        } else {
          addLayoutProperty(container, 'font-weight', '400');
        }
        
        // Font style (italic)
        if (fontStyle.includes('Italic')) {
          addLayoutProperty(container, 'font-style', 'italic');
        }
      }
      
      // Font size
      if (data.fontSize) {
        addLayoutProperty(container, 'font-size', `${data.fontSize}px`);
      }
      
      // Line height
      if (data.lineHeight) {
        let lineHeightValue;
        if (typeof data.lineHeight === 'object') {
          if (data.lineHeight.unit === 'PIXELS') {
            lineHeightValue = `${data.lineHeight.value}px`;
          } else if (data.lineHeight.unit === 'PERCENT') {
            lineHeightValue = `${data.lineHeight.value / 100}`;
          } else {
            lineHeightValue = data.lineHeight.value;
          }
        } else {
          lineHeightValue = 'normal';
        }
        addLayoutProperty(container, 'line-height', lineHeightValue);
      }
      
      // Letter spacing
      if (data.letterSpacing) {
        let letterSpacingValue;
        if (typeof data.letterSpacing === 'object') {
          if (data.letterSpacing.unit === 'PIXELS') {
            letterSpacingValue = `${data.letterSpacing.value}px`;
          } else if (data.letterSpacing.unit === 'PERCENT') {
            letterSpacingValue = `${data.letterSpacing.value / 100}em`;
          }
        }
        if (letterSpacingValue) {
          addLayoutProperty(container, 'letter-spacing', letterSpacingValue);
        }
      }
      
      // Text alignment
      if (data.textAlignHorizontal) {
        const alignmentMap = {
          'LEFT': 'left',
          'CENTER': 'center',
          'RIGHT': 'right',
          'JUSTIFIED': 'justify'
        };
        
        const textAlign = alignmentMap[data.textAlignHorizontal] || 'left';
        addLayoutProperty(container, 'text-align', textAlign);
      }
      
      // Text decoration
      if (data.textDecoration) {
        const decorationMap = {
          'UNDERLINE': 'underline',
          'STRIKETHROUGH': 'line-through'
        };
        
        const textDecoration = decorationMap[data.textDecoration];
        if (textDecoration) {
          addLayoutProperty(container, 'text-decoration', textDecoration);
        }
      }
      
      // Text transform
      if (data.textCase) {
        const caseMap = {
          'UPPER': 'uppercase',
          'LOWER': 'lowercase',
          'TITLE': 'capitalize',
          'ORIGINAL': 'none'
        };
        
        const textTransform = caseMap[data.textCase];
        if (textTransform && textTransform !== 'none') {
          addLayoutProperty(container, 'text-transform', textTransform);
        }
      }
      
      // Color - if the text has a fill
      if (data.fills && data.fills.length > 0 && data.fills[0].type === 'SOLID') {
        const fill = data.fills[0];
        const r = Math.round(fill.color.r * 255);
        const g = Math.round(fill.color.g * 255);
        const b = Math.round(fill.color.b * 255);
        const a = fill.opacity || 1;
        
        // Create hex color
        const hex = rgbToHex(r, g, b);
        addLayoutProperty(container, 'color', hex);
      }
    }

    // Function to update the box model visualization
    function updateBoxModel(data) {
      if (!data || typeof data.width !== 'number' || typeof data.height !== 'number') {
        document.querySelector('.parent-box-model').style.display = 'none';
        return;
      }
      
      document.querySelector('.parent-box-model').style.display = 'flex';
      
      // Helper function to safely convert any value to a number
      const toSafeNumber = (value) => {
        // Handle undefined, null, or symbol values
        if (value === undefined || value === null || typeof value === 'symbol') {
          return 0;
        }
        // If it's already a number, round it
        if (typeof value === 'number') {
          return Math.round(value);
        }
        // Try to convert to number, return 0 if fails
        const num = Number(value);
        return isNaN(num) ? 0 : Math.round(num);
      };
      
      // Update content dimensions
      const contentWidth = toSafeNumber(data.width);
      const contentHeight = toSafeNumber(data.height);
      document.getElementById('content-dimensions').textContent = `${contentWidth} × ${contentHeight}`;
      
      // Update padding values with safe conversion
      document.getElementById('padding-top').textContent = toSafeNumber(data.paddingTop);
      document.getElementById('padding-right').textContent = toSafeNumber(data.paddingRight);
      document.getElementById('padding-bottom').textContent = toSafeNumber(data.paddingBottom);
      document.getElementById('padding-left').textContent = toSafeNumber(data.paddingLeft);
      
      // Update border label and values
      const borderLabel = document.querySelector('.border-label');
      
      // Check for individual border radius values
      const hasIndividualRadii = [
        data.topLeftRadius,
        data.topRightRadius,
        data.bottomRightRadius,
        data.bottomLeftRadius
      ].some(value => typeof value === 'number');
      
      // Handle stroke weights first
      let strokeTop = 0, strokeRight = 0, strokeBottom = 0, strokeLeft = 0;
      
      // Check for strokes in the element
      if (data.strokes && data.strokes.length > 0) {
        const stroke = data.strokes[0];
        if (stroke.type === 'SOLID') {
          // Check for individual stroke weights
          if ([data.strokeTopWeight, data.strokeRightWeight, data.strokeBottomWeight, data.strokeLeftWeight].some(value => typeof value === 'number')) {
            strokeTop = toSafeNumber(data.strokeTopWeight);
            strokeRight = toSafeNumber(data.strokeRightWeight);
            strokeBottom = toSafeNumber(data.strokeBottomWeight);
            strokeLeft = toSafeNumber(data.strokeLeftWeight);
          } else if (typeof data.strokeWeight === 'number') {
            // Use uniform stroke weight
            strokeTop = strokeRight = strokeBottom = strokeLeft = toSafeNumber(data.strokeWeight);
          }
        }
      }

      // Update stroke values in the UI
      document.getElementById('stroke-top').textContent = strokeTop;
      document.getElementById('stroke-right').textContent = strokeRight;
      document.getElementById('stroke-bottom').textContent = strokeBottom;
      document.getElementById('stroke-left').textContent = strokeLeft;

      if (hasIndividualRadii) {
        borderLabel.textContent = "Border";
        
        document.getElementById('border-top').textContent = toSafeNumber(data.topLeftRadius);
        document.getElementById('border-right').textContent = toSafeNumber(data.topRightRadius);
        document.getElementById('border-bottom').textContent = toSafeNumber(data.bottomRightRadius);
        document.getElementById('border-left').textContent = toSafeNumber(data.bottomLeftRadius);
        return;
      }
      
      // Check for individual stroke weights
      const hasStrokeWeights = [
        data.strokeTopWeight,
        data.strokeRightWeight,
        data.strokeBottomWeight,
        data.strokeLeftWeight
      ].some(value => typeof value === 'number');
      
      if (hasStrokeWeights) {
        borderLabel.textContent = "Border";
        
        document.getElementById('border-top').textContent = toSafeNumber(data.strokeTopWeight);
        document.getElementById('border-right').textContent = toSafeNumber(data.strokeRightWeight);
        document.getElementById('border-bottom').textContent = toSafeNumber(data.strokeBottomWeight);
        document.getElementById('border-left').textContent = toSafeNumber(data.strokeLeftWeight);
        return;
      }
      
      // Default case: Use cornerRadius or strokeWeight
      const borderRadius = toSafeNumber(data.cornerRadius);
      const borderWeight = toSafeNumber(data.strokeWeight);
      
      // Use border radius or stroke weight depending on which is present
      const borderValue = borderRadius > 0 ? borderRadius : borderWeight;
      
      // Update the border label
      borderLabel.textContent = borderRadius > 0 ? "Border Radius" : "Border";
      
      // Set the same value for all sides
      document.getElementById('border-top').textContent = borderValue;
      document.getElementById('border-right').textContent = borderValue;
      document.getElementById('border-bottom').textContent = borderValue;
      document.getElementById('border-left').textContent = borderValue;
    }

    // Helper function to add layout property
    function addLayoutProperty(container, label, value) {
      const row = document.createElement('div');
      row.className = 'layout_row';
      row.innerHTML = `
        <span class="layout_label">${label} :</span>
        <span class="layout_value">${value};</span>
      `;
      container.appendChild(row);
    }

    // Helper function to convert Figma alignment to CSS flex alignment
    function getFlexAlignment(alignment) {
      const alignmentMap = {
        MIN: 'flex-start',
        CENTER: 'center',
        MAX: 'flex-end',
        SPACE_BETWEEN: 'space-between'
      };
      return alignmentMap[alignment] || 'flex-start';
    }

    // Copy layout CSS
    document.querySelector('.layout_copy_icon').addEventListener('click', () => {
      const layoutContent = document.querySelector('.layout_content');
      const cssText = Array.from(layoutContent.querySelectorAll('.layout_row'))
        .map(row => {
          const label = row.querySelector('.layout_label').textContent.replace(' :', '');
          const value = row.querySelector('.layout_value').textContent.replace(';', '');
          return `${label}: ${value};`;
        })
        .join('\n');
      
      // Add a appropriate CSS selector based on the element type
      const isText = document.getElementById('layout_title').textContent === 'Text CSS';
      const elementName = document.getElementById('element-name').textContent.toLowerCase().replace(/\s+/g, '-');
      const cssSelector = isText ? `/* ${elementName} */\n` : '';
      
      // Create temporary textarea for copying
      const textarea = document.createElement('textarea');
      textarea.value = cssSelector + cssText;
      textarea.setAttribute('readonly', '');
      textarea.style.position = 'absolute';
      textarea.style.left = '-9999px';
      document.body.appendChild(textarea);
      
      // Select and copy the text
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
      
      // Show Figma's toast notification
      parent.postMessage({ pluginMessage: { type: 'showToast', message: 'Copied to clipboard' } }, '*');
      
      // Show visual feedback
      const copyIcon = document.querySelector('.layout_copy_icon');
      copyIcon.style.opacity = '0.5';
      setTimeout(() => {
        copyIcon.style.opacity = '1';
      }, 200);
    });

    // Listen for messages from the plugin
    window.onmessage = event => {
      const message = event.data.pluginMessage;
      // Store the last message for format changes
      window.lastPluginMessage = message;
      if (message.type === 'selectionChange') {
        updateUI(message.data);
        updateAssets(message.data);
      } else if (message.type === 'exportComplete') {
        // Handle the exported asset data
        const { name, format, resolution, data } = message;
        
        // Create blob with the exported data
        const blob = new Blob([data], { type: `image/${format.toLowerCase()}` });
        const url = URL.createObjectURL(blob);
        
        // Create download link
        const link = document.createElement('a');
        link.href = url;
        link.download = `${name}_${resolution}.${format.toLowerCase()}`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        // Show success message
        parent.postMessage({ 
          pluginMessage: { 
            type: 'showToast', 
            message: `Asset downloaded at ${resolution} resolution!` 
          } 
        }, '*');
      }
    };

    // Function to update frame CSS properties
    function updateFrameLayout(data, container) {
      // Get the selected framework/language
      const framework = document.querySelector('.language-section-choice select').value;
      
      // Clear previous content
      container.innerHTML = '';
      
      switch (framework) {
        case 'css':
          generateDefaultCSS(data, container);
          break;
        case 'tailwindcss':
          generateTailwindCSS(data, container);
          break;
        case 'bootstrap':
          generateBootstrapClasses(data, container);
          break;
        case 'react':
          generateReactStyles(data, container);
          break;
        case 'vue':
          generateVueStyles(data, container);
          break;
        case 'svelte':
          generateSvelteStyles(data, container);
          break;
        case 'angular':
          generateAngularStyles(data, container);
          break;
        case 'qwik':
          generateQwikStyles(data, container);
          break;
        case 'swift':
          generateSwiftStyles(data, container);
          break;
        case 'flutter':
          generateFlutterStyles(data, container);
          break;
        case 'kotlin':
          generateKotlinStyles(data, container);
          break;
        default:
          generateDefaultCSS(data, container);
      }
    }

    // Function to generate Vue styles
    function generateVueStyles(data, container) {
      const styles = {};
      
      // Width and height
      if (data.width !== undefined) styles.width = `${Math.round(data.width)}px`;
      if (data.height !== undefined) styles.height = `${Math.round(data.height)}px`;
      
      // Padding
      if (data.paddingTop !== undefined || data.paddingRight !== undefined ||
          data.paddingBottom !== undefined || data.paddingLeft !== undefined) {
        const top = data.paddingTop || 0;
        const right = data.paddingRight || 0;
        const bottom = data.paddingBottom || 0;
        const left = data.paddingLeft || 0;
        
        if (top === right && right === bottom && bottom === left) {
          styles.padding = `${top}px`;
        } else {
          styles.padding = `${top}px ${right}px ${bottom}px ${left}px`;
        }
      }
      
      // Background color
      if (data.fills && data.fills.length > 0) {
        const solidFills = data.fills.filter(fill => fill.type === 'SOLID' && fill.visible !== false);
        if (solidFills.length > 0) {
          const fill = solidFills[0];
          const r = Math.round(fill.color.r * 255);
          const g = Math.round(fill.color.g * 255);
          const b = Math.round(fill.color.b * 255);
          const opacity = fill.opacity !== undefined ? fill.opacity : 1;
          
          styles.backgroundColor = opacity < 1
            ? `rgba(${r}, ${g}, ${b}, ${opacity.toFixed(2)})`
            : rgbToHex(r, g, b);
        }
      }
      
      addLayoutProperty(container, ':style', JSON.stringify(styles, null, 2));
    }

    // Function to generate Svelte styles
    function generateSvelteStyles(data, container) {
      const styles = [];
      
      // Width and height
      if (data.width !== undefined) styles.push(`width: ${Math.round(data.width)}px`);
      if (data.height !== undefined) styles.push(`height: ${Math.round(data.height)}px`);
      
      // Padding
      if (data.paddingTop !== undefined || data.paddingRight !== undefined ||
          data.paddingBottom !== undefined || data.paddingLeft !== undefined) {
        const top = data.paddingTop || 0;
        const right = data.paddingRight || 0;
        const bottom = data.paddingBottom || 0;
        const left = data.paddingLeft || 0;
        
        if (top === right && right === bottom && bottom === left) {
          styles.push(`padding: ${top}px`);
        } else {
          styles.push(`padding: ${top}px ${right}px ${bottom}px ${left}px`);
        }
      }
      
      addLayoutProperty(container, 'style', styles.join('; '));
    }

    // Function to generate Angular styles
    function generateAngularStyles(data, container) {
      const styles = {};
      
      // Width and height
      if (data.width !== undefined) styles.width = `${Math.round(data.width)}px`;
      if (data.height !== undefined) styles.height = `${Math.round(data.height)}px`;
      
      // Padding and other styles similar to Vue
      if (data.paddingTop !== undefined || data.paddingRight !== undefined ||
          data.paddingBottom !== undefined || data.paddingLeft !== undefined) {
        const top = data.paddingTop || 0;
        const right = data.paddingRight || 0;
        const bottom = data.paddingBottom || 0;
        const left = data.paddingLeft || 0;
        
        if (top === right && right === bottom && bottom === left) {
          styles.padding = `${top}px`;
        } else {
          styles.padding = `${top}px ${right}px ${bottom}px ${left}px`;
        }
      }
      
      addLayoutProperty(container, '[ngStyle]', JSON.stringify(styles, null, 2));
    }

    // Function to generate Qwik styles
    function generateQwikStyles(data, container) {
      const styles = {};
      
      // Width and height
      if (data.width !== undefined) styles.width = `${Math.round(data.width)}px`;
      if (data.height !== undefined) styles.height = `${Math.round(data.height)}px`;
      
      // Add Qwik-specific styles
      addLayoutProperty(container, 'style', JSON.stringify(styles, null, 2));
    }

    // Function to generate Swift styles
    function generateSwiftStyles(data, container) {
      const styles = [];
      
      // Width and height
      if (data.width !== undefined) styles.push(`width: ${Math.round(data.width)}`);
      if (data.height !== undefined) styles.push(`height: ${Math.round(data.height)}`);
      
      // Add Swift-specific modifiers
      if (data.cornerRadius) {
        styles.push(`cornerRadius: ${data.cornerRadius}`);
      }
      
      addLayoutProperty(container, '.frame(', styles.join(', ') + ')');
    }

    // Function to generate Flutter styles
    function generateFlutterStyles(data, container) {
      const styles = [];
      
      // Width and height
      if (data.width !== undefined) styles.push(`width: ${Math.round(data.width)}.0`);
      if (data.height !== undefined) styles.push(`height: ${Math.round(data.height)}.0`);
      
      // Add Flutter-specific properties
      if (data.cornerRadius) {
        styles.push(`borderRadius: BorderRadius.circular(${data.cornerRadius}.0)`);
      }
      
      addLayoutProperty(container, 'Container(', styles.join(',\n  '));
    }

    // Function to generate Kotlin styles
    function generateKotlinStyles(data, container) {
      const styles = [];
      
      // Width and height
      if (data.width !== undefined) styles.push(`width = ${Math.round(data.width)}.dp`);
      if (data.height !== undefined) styles.push(`height = ${Math.round(data.height)}.dp`);
      
      // Add Kotlin Compose modifiers
      if (data.cornerRadius) {
        styles.push(`clip(RoundedCornerShape(${data.cornerRadius}.dp))`);
      }
      
      addLayoutProperty(container, 'Modifier', styles.join('\n    .'));
    }

    // Function to generate Tailwind CSS classes
    function generateTailwindCSS(data, container) {
      let classes = [];
      
      // Width and height
      if (data.width !== undefined) {
        classes.push(`w-[${Math.round(data.width)}px]`);
      }
      if (data.height !== undefined) {
        classes.push(`h-[${Math.round(data.height)}px]`);
      }
      
      // Padding
      if (data.paddingTop !== undefined || data.paddingRight !== undefined ||
          data.paddingBottom !== undefined || data.paddingLeft !== undefined) {
        const top = data.paddingTop || 0;
        const right = data.paddingRight || 0;
        const bottom = data.paddingBottom || 0;
        const left = data.paddingLeft || 0;
        
        if (top === right && right === bottom && bottom === left) {
          classes.push(`p-[${top}px]`);
        } else {
          if (top > 0) classes.push(`pt-[${top}px]`);
          if (right > 0) classes.push(`pr-[${right}px]`);
          if (bottom > 0) classes.push(`pb-[${bottom}px]`);
          if (left > 0) classes.push(`pl-[${left}px]`);
        }
      }
      
      // Background color
      if (data.fills && data.fills.length > 0) {
        const solidFills = data.fills.filter(fill => fill.type === 'SOLID' && fill.visible !== false);
        if (solidFills.length > 0) {
          const fill = solidFills[0];
          const r = Math.round(fill.color.r * 255);
          const g = Math.round(fill.color.g * 255);
          const b = Math.round(fill.color.b * 255);
          const opacity = fill.opacity !== undefined ? fill.opacity : 1;
          
          classes.push(`bg-[${rgbToHex(r, g, b)}]`);
          if (opacity < 1) {
            classes.push(`bg-opacity-[${Math.round(opacity * 100)}]`);
          }
        }
      }
      
      // Border
      if (data.strokes && data.strokes.length > 0) {
        const solidStrokes = data.strokes.filter(stroke => stroke.type === 'SOLID' && stroke.visible !== false);
        if (solidStrokes.length > 0 && data.strokeWeight) {
          const stroke = solidStrokes[0];
          const r = Math.round(stroke.color.r * 255);
          const g = Math.round(stroke.color.g * 255);
          const b = Math.round(stroke.color.b * 255);
          
          classes.push(`border-[${data.strokeWeight}px]`);
          classes.push(`border-[${rgbToHex(r, g, b)}]`);
        }
      }
      
      // Border radius
      if (data.cornerRadius !== undefined && data.cornerRadius > 0) {
        classes.push(`rounded-[${data.cornerRadius}px]`);
      }
      
      // Flexbox
      if (data.layoutMode) {
        classes.push('flex');
        classes.push(data.layoutMode === 'HORIZONTAL' ? 'flex-row' : 'flex-col');
        
        if (data.primaryAxisAlignItems) {
          const justifyMap = {
            'MIN': 'justify-start',
            'CENTER': 'justify-center',
            'MAX': 'justify-end',
            'SPACE_BETWEEN': 'justify-between'
          };
          classes.push(justifyMap[data.primaryAxisAlignItems] || 'justify-start');
        }
        
        if (data.counterAxisAlignItems) {
          const alignMap = {
            'MIN': 'items-start',
            'CENTER': 'items-center',
            'MAX': 'items-end'
          };
          classes.push(alignMap[data.counterAxisAlignItems] || 'items-start');
        }
        
        if (data.itemSpacing) {
          classes.push(`gap-[${data.itemSpacing}px]`);
        }
      }
      
      // Add the classes to the container
      addLayoutProperty(container, 'className', classes.join(' '));
    }

    // Function to generate React styles
    function generateReactStyles(data, container) {
      const styles = {};
      
      // Width and height
      if (data.width !== undefined) styles.width = `${Math.round(data.width)}px`;
      if (data.height !== undefined) styles.height = `${Math.round(data.height)}px`;
      
      // Padding
      if (data.paddingTop !== undefined || data.paddingRight !== undefined ||
          data.paddingBottom !== undefined || data.paddingLeft !== undefined) {
        const top = data.paddingTop || 0;
        const right = data.paddingRight || 0;
        const bottom = data.paddingBottom || 0;
        const left = data.paddingLeft || 0;
        
        if (top === right && right === bottom && bottom === left) {
          styles.padding = `${top}px`;
        } else {
          styles.padding = `${top}px ${right}px ${bottom}px ${left}px`;
        }
      }
      
      // Background color
      if (data.fills && data.fills.length > 0) {
        const solidFills = data.fills.filter(fill => fill.type === 'SOLID' && fill.visible !== false);
        if (solidFills.length > 0) {
          const fill = solidFills[0];
          const r = Math.round(fill.color.r * 255);
          const g = Math.round(fill.color.g * 255);
          const b = Math.round(fill.color.b * 255);
          const opacity = fill.opacity !== undefined ? fill.opacity : 1;
          
          styles.backgroundColor = opacity < 1
            ? `rgba(${r}, ${g}, ${b}, ${opacity.toFixed(2)})`
            : rgbToHex(r, g, b);
        }
      }
      
      // Border
      if (data.strokes && data.strokes.length > 0) {
        const solidStrokes = data.strokes.filter(stroke => stroke.type === 'SOLID' && stroke.visible !== false);
        if (solidStrokes.length > 0 && data.strokeWeight) {
          const stroke = solidStrokes[0];
          const r = Math.round(stroke.color.r * 255);
          const g = Math.round(stroke.color.g * 255);
          const b = Math.round(stroke.color.b * 255);
          const opacity = stroke.opacity !== undefined ? stroke.opacity : 1;
          
          styles.borderWidth = `${data.strokeWeight}px`;
          styles.borderStyle = 'solid';
          styles.borderColor = opacity < 1
            ? `rgba(${r}, ${g}, ${b}, ${opacity.toFixed(2)})`
            : rgbToHex(r, g, b);
        }
      }
      
      // Border radius
      if (data.cornerRadius !== undefined && data.cornerRadius > 0) {
        styles.borderRadius = `${data.cornerRadius}px`;
      }
      
      // Flexbox
      if (data.layoutMode) {
        styles.display = 'flex';
        styles.flexDirection = data.layoutMode === 'HORIZONTAL' ? 'row' : 'column';
        
        if (data.primaryAxisAlignItems) {
          const justifyMap = {
            'MIN': 'flex-start',
            'CENTER': 'center',
            'MAX': 'flex-end',
            'SPACE_BETWEEN': 'space-between'
          };
          styles.justifyContent = justifyMap[data.primaryAxisAlignItems] || 'flex-start';
        }
        
        if (data.counterAxisAlignItems) {
          const alignMap = {
            'MIN': 'flex-start',
            'CENTER': 'center',
            'MAX': 'flex-end'
          };
          styles.alignItems = alignMap[data.counterAxisAlignItems] || 'flex-start';
        }
        
        if (data.itemSpacing) {
          styles.gap = `${data.itemSpacing}px`;
        }
      }
      
      // Convert styles object to string
      const styleString = Object.entries(styles)
        .map(([key, value]) => `  ${key}: '${value}'`)
        .join(',\n');
      
      addLayoutProperty(container, 'style', `{\n${styleString}\n}`);
    }

    // Function to generate Bootstrap classes
    function generateBootstrapClasses(data, container) {
      let classes = [];
      
      // Width and height
      if (data.width !== undefined) classes.push(`w-${Math.round(data.width)}`);
      if (data.height !== undefined) classes.push(`h-${Math.round(data.height)}`);
      
      // Padding
      if (data.paddingTop !== undefined || data.paddingRight !== undefined ||
          data.paddingBottom !== undefined || data.paddingLeft !== undefined) {
        const top = data.paddingTop || 0;
        const right = data.paddingRight || 0;
        const bottom = data.paddingBottom || 0;
        const left = data.paddingLeft || 0;
        
        if (top === right && right === bottom && bottom === left) {
          classes.push(`p-${Math.round(top / 4)}`);
        } else {
          if (top > 0) classes.push(`pt-${Math.round(top / 4)}`);
          if (right > 0) classes.push(`pe-${Math.round(right / 4)}`);
          if (bottom > 0) classes.push(`pb-${Math.round(bottom / 4)}`);
          if (left > 0) classes.push(`ps-${Math.round(left / 4)}`);
        }
      }
      
      // Flexbox
      if (data.layoutMode) {
        classes.push('d-flex');
        classes.push(data.layoutMode === 'HORIZONTAL' ? 'flex-row' : 'flex-column');
        
        if (data.primaryAxisAlignItems) {
          const justifyMap = {
            'MIN': 'justify-content-start',
            'CENTER': 'justify-content-center',
            'MAX': 'justify-content-end',
            'SPACE_BETWEEN': 'justify-content-between'
          };
          classes.push(justifyMap[data.primaryAxisAlignItems] || 'justify-content-start');
        }
        
        if (data.counterAxisAlignItems) {
          const alignMap = {
            'MIN': 'align-items-start',
            'CENTER': 'align-items-center',
            'MAX': 'align-items-end'
          };
          classes.push(alignMap[data.counterAxisAlignItems] || 'align-items-start');
        }
        
        if (data.itemSpacing) {
          classes.push(`gap-${Math.round(data.itemSpacing / 4)}`);
        }
      }
      
      // Border radius
      if (data.cornerRadius !== undefined && data.cornerRadius > 0) {
        classes.push(`rounded-${Math.round(data.cornerRadius / 4)}`);
      }
      
      // Add the classes to the container
      addLayoutProperty(container, 'class', classes.join(' '));
      
      // Add custom styles for colors and specific dimensions
      const styles = [];
      
      // Background color
      if (data.fills && data.fills.length > 0) {
        const solidFills = data.fills.filter(fill => fill.type === 'SOLID' && fill.visible !== false);
        if (solidFills.length > 0) {
          const fill = solidFills[0];
          const r = Math.round(fill.color.r * 255);
          const g = Math.round(fill.color.g * 255);
          const b = Math.round(fill.color.b * 255);
          const opacity = fill.opacity !== undefined ? fill.opacity : 1;
          
          styles.push(`background-color: ${opacity < 1
            ? `rgba(${r}, ${g}, ${b}, ${opacity.toFixed(2)})`
            : rgbToHex(r, g, b)}`);
        }
      }
      
      // Add custom styles if any
      if (styles.length > 0) {
        addLayoutProperty(container, 'style', styles.join('; '));
      }
    }

    // Function to generate framework-specific styles (Vue, Svelte, Angular, etc.)
    function generateFrameworkStyles(data, container, framework) {
      let prefix = '';
      let suffix = '';
      
      switch (framework) {
        case 'vue':
          prefix = ':style="';
          suffix = '"';
          break;
        case 'svelte':
          prefix = 'style="';
          suffix = '"';
          break;
        case 'angular':
          prefix = '[ngStyle]="';
          suffix = '"';
          break;
        default:
          prefix = 'style="';
          suffix = '"';
      }
      
      const styles = [];
      
      // Width and height
      if (data.width !== undefined) styles.push(`width: ${Math.round(data.width)}px`);
      if (data.height !== undefined) styles.push(`height: ${Math.round(data.height)}px`);
      
      // Padding
      if (data.paddingTop !== undefined || data.paddingRight !== undefined ||
          data.paddingBottom !== undefined || data.paddingLeft !== undefined) {
        const top = data.paddingTop || 0;
        const right = data.paddingRight || 0;
        const bottom = data.paddingBottom || 0;
        const left = data.paddingLeft || 0;
        
        if (top === right && right === bottom && bottom === left) {
          styles.push(`padding: ${top}px`);
        } else {
          styles.push(`padding: ${top}px ${right}px ${bottom}px ${left}px`);
        }
      }
      
      // Background color
      if (data.fills && data.fills.length > 0) {
        const solidFills = data.fills.filter(fill => fill.type === 'SOLID' && fill.visible !== false);
        if (solidFills.length > 0) {
          const fill = solidFills[0];
          const r = Math.round(fill.color.r * 255);
          const g = Math.round(fill.color.g * 255);
          const b = Math.round(fill.color.b * 255);
          const opacity = fill.opacity !== undefined ? fill.opacity : 1;
          
          styles.push(`background-color: ${opacity < 1
            ? `rgba(${r}, ${g}, ${b}, ${opacity.toFixed(2)})`
            : rgbToHex(r, g, b)}`);
        }
      }
      
      // Border
      if (data.strokes && data.strokes.length > 0) {
        const solidStrokes = data.strokes.filter(stroke => stroke.type === 'SOLID' && stroke.visible !== false);
        if (solidStrokes.length > 0 && data.strokeWeight) {
          const stroke = solidStrokes[0];
          const r = Math.round(stroke.color.r * 255);
          const g = Math.round(stroke.color.g * 255);
          const b = Math.round(stroke.color.b * 255);
          const opacity = stroke.opacity !== undefined ? stroke.opacity : 1;
          
          styles.push(`border: ${data.strokeWeight}px solid ${opacity < 1
            ? `rgba(${r}, ${g}, ${b}, ${opacity.toFixed(2)})`
            : rgbToHex(r, g, b)}`);
        }
      }
      
      // Border radius
      if (data.cornerRadius !== undefined && data.cornerRadius > 0) {
        styles.push(`border-radius: ${data.cornerRadius}px`);
      }
      
      // Flexbox
      if (data.layoutMode) {
        styles.push('display: flex');
        styles.push(`flex-direction: ${data.layoutMode === 'HORIZONTAL' ? 'row' : 'column'}`);
        
        if (data.primaryAxisAlignItems) {
          const justifyMap = {
            'MIN': 'flex-start',
            'CENTER': 'center',
            'MAX': 'flex-end',
            'SPACE_BETWEEN': 'space-between'
          };
          styles.push(`justify-content: ${justifyMap[data.primaryAxisAlignItems] || 'flex-start'}`);
        }
        
        if (data.counterAxisAlignItems) {
          const alignMap = {
            'MIN': 'flex-start',
            'CENTER': 'center',
            'MAX': 'flex-end'
          };
          styles.push(`align-items: ${alignMap[data.counterAxisAlignItems] || 'flex-start'}`);
        }
        
        if (data.itemSpacing) {
          styles.push(`gap: ${data.itemSpacing}px`);
        }
      }
      
      // Add the styles to the container
      addLayoutProperty(container, prefix + styles.join('; ') + suffix, '');
    }

    // Function to generate default CSS
    function generateDefaultCSS(data, container) {
      // Add layout mode properties if available
      if (data.layoutMode) {
        const layoutMode = data.layoutMode === 'HORIZONTAL' ? 'row' : 'column';
        addLayoutProperty(container, 'display', 'flex');
        addLayoutProperty(container, 'flex-direction', layoutMode);
        
        if (data.primaryAxisAlignItems) {
          addLayoutProperty(container, 'justify-content', getFlexAlignment(data.primaryAxisAlignItems));
        }
        if (data.counterAxisAlignItems) {
          addLayoutProperty(container, 'align-items', getFlexAlignment(data.counterAxisAlignItems));
        }
        if (data.itemSpacing) {
          addLayoutProperty(container, 'gap', data.itemSpacing + 'px');
        }
      }
      
      // Add size properties
      if (data.width !== undefined) {
        addLayoutProperty(container, 'width', `${Math.round(data.width)}px`);
      }
      if (data.height !== undefined) {
        addLayoutProperty(container, 'height', `${Math.round(data.height)}px`);
      }
      
      // Add padding properties if available
      if (data.paddingTop !== undefined || data.paddingRight !== undefined ||
          data.paddingBottom !== undefined || data.paddingLeft !== undefined) {
        
        const top = data.paddingTop || 0;
        const right = data.paddingRight || 0;
        const bottom = data.paddingBottom || 0;
        const left = data.paddingLeft || 0;
        
        if (top === right && right === bottom && bottom === left) {
          addLayoutProperty(container, 'padding', `${top}px`);
        } else if (top === bottom && left === right) {
          addLayoutProperty(container, 'padding', `${top}px ${right}px`);
        } else {
          addLayoutProperty(container, 'padding', `${top}px ${right}px ${bottom}px ${left}px`);
        }
      }
      
      // Add background color if available
      if (data.fills && data.fills.length > 0) {
        const solidFills = data.fills.filter(fill => fill.type === 'SOLID' && fill.visible !== false);
        if (solidFills.length > 0) {
          const fill = solidFills[0];
          const r = Math.round(fill.color.r * 255);
          const g = Math.round(fill.color.g * 255);
          const b = Math.round(fill.color.b * 255);
          const opacity = fill.opacity !== undefined ? fill.opacity : 1;
          
          if (opacity < 1) {
            addLayoutProperty(container, 'background-color', `rgba(${r}, ${g}, ${b}, ${opacity.toFixed(2)})`);
          } else {
            addLayoutProperty(container, 'background-color', rgbToHex(r, g, b));
          }
        }
      }
      
      // Add border properties if available
      if (data.strokes && data.strokes.length > 0) {
        const solidStrokes = data.strokes.filter(stroke => stroke.type === 'SOLID' && stroke.visible !== false);
        if (solidStrokes.length > 0 && data.strokeWeight) {
          const stroke = solidStrokes[0];
          const r = Math.round(stroke.color.r * 255);
          const g = Math.round(stroke.color.g * 255);
          const b = Math.round(stroke.color.b * 255);
          const opacity = stroke.opacity !== undefined ? stroke.opacity : 1;
          
          addLayoutProperty(container, 'border-width', `${data.strokeWeight}px`);
          if (opacity < 1) {
            addLayoutProperty(container, 'border-color', `rgba(${r}, ${g}, ${b}, ${opacity.toFixed(2)})`);
          } else {
            addLayoutProperty(container, 'border-color', rgbToHex(r, g, b));
          }
          addLayoutProperty(container, 'border-style', 'solid');
        }
      }
      
      // Add border radius if available
      if (data.cornerRadius !== undefined && data.cornerRadius > 0) {
        addLayoutProperty(container, 'border-radius', `${data.cornerRadius}px`);
      }
    }

    // Add event listener for framework/language change
    document.querySelector('.language-section-choice select').addEventListener('change', (e) => {
      // Get the last received data from the plugin
      const lastMessage = window.lastPluginMessage;
      if (lastMessage && lastMessage.type === 'selectionChange' && lastMessage.data) {
        const layoutContent = document.querySelector('.layout_content');
        updateFrameLayout(lastMessage.data, layoutContent);
      }
    });

    // Function to update the color preview
    function updateColorPreview(data) {
      const colorsList = document.getElementById('colors-list');
      colorsList.innerHTML = ''; // Clear existing colors
      
      let hasColors = false;
      let isExpanded = false;
      let currentFormat = document.querySelector('.section-choice select').value;
      
      // Process all colors from the node and its children
      if (data.allColors && data.allColors.length > 0) {
        const solidColors = data.allColors.filter(color => color.type === 'SOLID' && color.visible !== false);
        
        if (solidColors.length > 0) {
          hasColors = true;
          
          // Function to render colors
          const renderColors = (colors) => {
            colors.forEach(color => {
              const r = Math.round(color.color.r * 255);
              const g = Math.round(color.color.g * 255);
              const b = Math.round(color.color.b * 255);
              const opacity = color.opacity !== undefined ? color.opacity : 1;
              
              // Create hex color for preview
              const hex = rgbToHex(r, g, b);
              
              // Create color item
              const colorItem = document.createElement('div');
              colorItem.className = 'color-item';
              
              // Add click handler to copy color value
              colorItem.addEventListener('click', () => {
                const colorValue = getColorValue(r, g, b, opacity, currentFormat);
                const textarea = document.createElement('textarea');
                textarea.value = colorValue;
                textarea.setAttribute('readonly', '');
                textarea.style.position = 'absolute';
                textarea.style.left = '-9999px';
                document.body.appendChild(textarea);
                
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                
                parent.postMessage({ pluginMessage: { type: 'showToast', message: 'Copied to clipboard' } }, '*');
                
                colorItem.style.backgroundColor = 'rgba(255, 255, 255, 0.1)';
                setTimeout(() => {
                  colorItem.style.backgroundColor = '';
                }, 200);
              });
              
              // Create left section (color preview and color value)
              const colorLeft = document.createElement('div');
              colorLeft.className = 'color-left';
              
              const colorPreview = document.createElement('div');
              colorPreview.className = 'color-preview';
              colorPreview.style.backgroundColor = hex;
              
              const colorValues = document.createElement('div');
              colorValues.className = 'color-values';
              
              const colorValue = document.createElement('span');
              colorValue.textContent = getDisplayValue(r, g, b, opacity, currentFormat);
              
              const colorRight = document.createElement('div');
              colorRight.className = 'color-right';
              colorRight.textContent = color.nodeName;
              
              colorValues.appendChild(colorValue);
              colorLeft.appendChild(colorPreview);
              colorLeft.appendChild(colorValues);
              colorItem.appendChild(colorLeft);
              colorItem.appendChild(colorRight);
              colorsList.appendChild(colorItem);
            });
          };

          // Initially show only first 5 colors
          renderColors(solidColors.slice(0, 5));

          // Add "see all" button if there are more than 5 colors
          if (solidColors.length > 5) {
            const seeAllButton = document.createElement('div');
            seeAllButton.style.fontSize = '12px';
            seeAllButton.style.color = 'rgba(255, 255, 255, 0.7)';
            seeAllButton.style.cursor = 'pointer';
            seeAllButton.style.padding = '8px 16px';
            seeAllButton.textContent = `See all ${solidColors.length} colors`;
            
            seeAllButton.addEventListener('click', () => {
              if (!isExpanded) {
                colorsList.innerHTML = ''; // Clear current list
                renderColors(solidColors); // Show all colors
                seeAllButton.textContent = 'Show less';
                isExpanded = true;
              } else {
                colorsList.innerHTML = ''; // Clear current list
                renderColors(solidColors.slice(0, 5)); // Show first 5 colors
                seeAllButton.textContent = `See all ${solidColors.length} colors`;
                isExpanded = false;
              }
            });
            
            colorsList.appendChild(seeAllButton);
          }
        }
      }
      
      // Show/hide the colors section based on whether we found any colors
      document.getElementById('colors-section').style.display = hasColors ? 'block' : 'none';
    }

    // Add event listener for format change
    document.querySelector('.section-choice select').addEventListener('change', (e) => {
      // Get the last received data from the plugin
      const lastMessage = window.lastPluginMessage;
      if (lastMessage && lastMessage.type === 'selectionChange' && lastMessage.data) {
        updateColorPreview(lastMessage.data);
      }
    });

    // Function to update the UI with assets
    function updateAssets(data) {
      const assetsList = document.getElementById('assets-list');
      const assetsSection = document.getElementById('assets-section');
      
      if (!data || !data.assets || data.assets.length === 0) {
        assetsSection.style.display = 'none';
        return;
      }
      
      assetsSection.style.display = 'block';
      assetsList.innerHTML = '';
      
      data.assets.forEach(asset => {
        const assetItem = document.createElement('div');
        assetItem.className = 'asset-item';
        
        // Create left section with preview and info
        const assetLeft = document.createElement('div');
        assetLeft.className = 'asset-left';
        
        // Create preview container
        const assetPreview = document.createElement('div');
        assetPreview.className = 'asset-preview';
        
        // If we have fill color information, use it to determine background
        if (data.fills && data.fills.length > 0) {
          const fill = data.fills[0];
          if (fill.type === 'SOLID') {
            const r = Math.round(fill.color.r * 255);
            const g = Math.round(fill.color.g * 255);
            const b = Math.round(fill.color.b * 255);
            const brightness = calculateBrightness(r, g, b);
            
            // If the vector is light, use dark background
            if (brightness < 160) {
              assetPreview.style.backgroundColor = '#FFFFFF';
            } else {
              assetPreview.style.backgroundColor = '#1E1E1E';
            }
          }
        }
        
        // Find PNG export for preview
        const pngExport = asset.exports.find(exp => exp.format === 'PNG');
        if (pngExport) {
          const img = document.createElement('img');
          img.src = `data:image/png;base64,${arrayBufferToBase64(pngExport.data)}`;
          assetPreview.appendChild(img);
        }
        
        // Create info section
        const assetInfo = document.createElement('div');
        assetInfo.className = 'asset-info';
        
        const assetName = document.createElement('div');
        assetName.className = 'asset-name';
        assetName.textContent = asset.name;
        
        const assetType = document.createElement('div');
        assetType.className = 'asset-type';
        assetType.textContent = `${Math.round(asset.width)} × ${Math.round(asset.height)}`;
        
        assetInfo.appendChild(assetName);
        assetInfo.appendChild(assetType);
        
        assetLeft.appendChild(assetPreview);
        assetLeft.appendChild(assetInfo);
        
        // Create right section with format select and download button
        const assetRight = document.createElement('div');
        assetRight.className = 'asset-right';
        
        // Create format select
        const formatSelect = document.createElement('select');
        formatSelect.className = 'asset-format-select';
        
        // Create resolution select
        const resolutionSelect = document.createElement('select');
        resolutionSelect.className = 'asset-resolution-select';
        
        // Add resolution options
        const resolutions = ['0.5x', '0.75x', '1x', '1.5x', '2x', '3x', '4x', '512w', '512h'];
        resolutions.forEach(res => {
          const option = document.createElement('option');
          option.value = res;
          option.textContent = res;
          if (res === '1x') option.selected = true;
          resolutionSelect.appendChild(option);
        });

        // Add available formats
        asset.exports.forEach(exp => {
          const option = document.createElement('option');
          option.value = exp.format.toLowerCase();
          option.textContent = exp.format;
          formatSelect.appendChild(option);
        });

        // Show/hide resolution select based on format
        formatSelect.addEventListener('change', (e) => {
          resolutionSelect.style.display = e.target.value === 'png' ? 'inline-block' : 'none';
        });
        
        const downloadButton = document.createElement('div');
        downloadButton.className = 'asset-download';
        
        const downloadIcon = document.createElement('div');
        downloadIcon.className = 'download-icon';
        
        downloadButton.appendChild(downloadIcon);
        
        // Update click handler for download to include resolution
        downloadButton.addEventListener('click', () => {
          const format = formatSelect.value.toUpperCase();
          const resolution = format === 'PNG' ? resolutionSelect.value : '1x';
          
          // Send message to plugin to get the correct resolution export
          parent.postMessage({
            pluginMessage: {
              type: 'exportAsset',
              nodeId: asset.id,
              format: format,
              resolution: resolution,
              name: asset.name
            }
          }, '*');
        });
        
        assetRight.appendChild(formatSelect);
        assetRight.appendChild(resolutionSelect);
        assetRight.appendChild(downloadButton);
        
        // Assemble the asset item
        assetItem.appendChild(assetLeft);
        assetItem.appendChild(assetRight);
        
        assetsList.appendChild(assetItem);
      });
    }
    
    // Helper function to convert ArrayBuffer to base64
    function arrayBufferToBase64(buffer) {
      let binary = '';
      const bytes = new Uint8Array(buffer);
      const len = bytes.byteLength;
      for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return window.btoa(binary);
    }

    // Add this helper function to calculate color brightness
    function calculateBrightness(r, g, b) {
      // Using the HSP color model which better matches human perception
      // See: http://alienryderflex.com/hsp.html
      return Math.sqrt(
        0.299 * (r * r) +
        0.587 * (g * g) +
        0.114 * (b * b)
      );
    }
  </script>
</body>
</html> 